# OpenSCAD-generator by Bardynin Dmitry aka Eruman
# Astrakhan 2018-2019
			
gen::add_generator OpenSCAD.org gen_openscad::generate

namespace eval gen_openscad {

# Autogenerated with DRAKON Editor 1.26

set correct "cylinder cube sphere polyhedron import linear_extrude \
rotate_extrude surface "

set prog_loop ""
set prog_head ""
set prog_setup ""

proc build_declaration { name signature } {
    #item 80
    	unpack $signature type access parameters returns
    	set params {}
    	foreach par $parameters {
    		lappend params [ lindex $par 0 ]
    	}
    	set param_text [ join $params ", " ]
    	if { $type == "procedure" } {
    		return "$returns $name\($param_text\) \{"
    	} else {
    		return "$name\($param_text\) \{"
    	}
}

proc extract_signature { text name } {
    #item 92
    	#set a [split $name " "]
	set a [split $name ")"]
	#log "\n text >>> $text \n"
    set lines [ gen::separate_from_comments $text ]
	#tk_messageBox -icon info -message $lines -title "lines"    
	set first_line [ lindex $lines 0 ]
    	set first [ lindex $first_line 0 ]
    	if { $first == "#comment" } {
    		return [ list {} [ gen::create_signature "comment" {} {} {} ]]
    	}
    	
    	set type "procedure"
    	if { $first == "ctr" } {
    		set type "ctr"
    		set lines [ lrange $lines 1 end ]
    	}
    
    	set last [ lindex $lines end ]
    	set returns_expr [ lindex $last 0 ]
    	if { [ string match "returns *" $returns_expr ] } {
    		set returns [ lindex $returns_expr 1 ]
    		set parameters [ lrange $lines 0 end-1 ]
    	} else {
    		if { [lindex $a 1] == "" } {
    			#set returns "void" 
			set returns "module" 
    		} else {
    			#set returns "// No void SUB \"[lindex $a 1]\" \n" 
    			set returns "" 
    		}
    		set parameters $lines
    	}
    	return [ list {} [ gen::create_signature $type public $parameters $returns ] ]
}

proc generate { db gdb filename } {
    #item 74
    set gen::legalLoop "{for (*} \
        for(* difference()* union()* intersection()* \
        translate(* повторить(* repeat(* \
        color(* hull()* mirror(* linear_extrude(* offset(* \
        rotate(* scale(* resize(* multmatrix(* minkowski(* " 

# set gen_openscad::prog_loop [ newline_cut [ join [ $gdb eval {
#		select text
#		from items
#		where type = "beginend" AND ( text2 == "main")
#	} ]]] 

    set gen_openscad::prog_setup [ newline_cut [ join [ $gdb eval {
        select text
        from items
        where type = "beginend" AND ( text2 == "setup")
    } ]]]
    #if { $gen_openscad::prog_loop == "" && $gen_openscad::prog_setup == "" } {error "Отсутствует Пусковая диаграмма и Циклическая диаграмма. Укажите Пусковую или Циклическую диаграмму, щелкнув правой кнопкой по Началу соответствующей схемы. Можно указать обе диаграммы, при этом Пусковая выполнится однократно при запуске Ардуино, а Циклическая диаграмма будет выполняться многократно после Пусковой."}

    set gen_openscad::prog_head [ newline_cut [ join [ $gdb eval {
        select text
        from items
        where type = "beginend" AND ( text2 == "header")
    } ]]]
    #if {$gen_openscad::prog_head == "" } {error "Укажите Вступительную диаграмму, щелкнув правой кнопкой по Началу соответствующей схемы."}
    #tk_messageBox -icon info -message "prog_head!$gen_openscad::prog_head!prog_setup!$gen_openscad::prog_setup!prog_loop!$gen_openscad::prog_loop"
    set names [ $gdb eval {
        SELECT name FROM diagrams
        } ]
    #$gen_openscad::correct
    set newnames ""
    foreach name $names {
        set s1 [string first ")" $name ]
        if { $s1 > 0 } { set name [string range $name $s1+1 end] }
        set name [string trimleft $name]
        set name [string trimright $name]
        append newnames " \{" $name "\}"
        #tk_messageBox -icon info -message "name:$name*" -title "newnames:$newnames*"
    }
    #tk_messageBox -icon info -message "gen_openscad::correct:$gen_openscad::correct *" -title "names:$newnames*"
    append gen_openscad::correct $newnames
    #tk_messageBox -icon info -message "gen_openscad::correct:$gen_openscad::correct *" -title "names:$newnames*"

    log "started..."
    log ">"
        set diagrams [ $gdb eval {
    	    select diagram_id
        	from vertices
        	group by diagram_id
            }]

        set _col1768 $diagrams
        set _len1768 [ llength $_col1768 ]
        set _ind1768 0
        while { 1 } {
			if {$_ind1768 < $_len1768} {
			} else {
				break
			}
			set diagram_id [ lindex $_col1768 $_ind1768 ]
			# Обработать все диаграммы для корректировки
			rewire_wiring_pause $gdb $diagram_id
			rewire_wiring_pause_ins $gdb $diagram_id
			rewire_wiring_insertion $gdb $diagram_id
            rewire_wiring_output $gdb $diagram_id
			rewire_wiring_input $gdb $diagram_id
            rewire_wiring_output_simple $gdb $diagram_id
			rewire_wiring_input_simple $gdb $diagram_id
			rewire_wiring_timer $gdb $diagram_id
			rewire_wiring_process $gdb $diagram_id
			rewire_wiring_shelf $gdb $diagram_id

			rewire_wiring_loopstart $gdb $diagram_id
			rewire_wiring_if $gdb $diagram_id
			# Отключить все диаграммы с изменением цвета
			rewire_color $gdb $diagram_id
			incr _ind1768
		}

    	set callbacks [ make_callbacks ]
    	gen::fix_graph $gdb $callbacks 1
    	unpack [ gen::scan_file_description $db { header footer } ] header footer
#######################################################
		set timers [ $gdb eval {
		    select text
		    from vertices
		    where type = 'timer' } ]
		foreach n $timers {
		    set n [ mytranslit_declaration $n ]
		    set n [ my_name_translit $n ]
		    #log "unsigned long  $n ;"
		    set n [ split $n "="]
		    append header "\n unsigned long  [lindex $n 0] ;\n"
		}    	
        set use_nogoto 1
    	set functions [ gen::generate_functions $db $gdb $callbacks $use_nogoto ]
    	if { [ graph::errors_occured ] } { return }
    	set hfile [ replace_extension $filename "scad" ]
            set hname [ mytranslit_declaration  [file tail $hfile] ]
            set hname [ string map {" " "_"} $hname ]
            set hfile [file dirname $hfile]/$hname
        set f [ open $hfile w ]
    	catch {

    		p.print_to_file $f $functions $header $footer $use_nogoto 
    	} error_message
    	catch { close $f }
    #item 103
    set f [open $hfile r] 
    while {![eof $f]} { 
    	lappend ipList [gets $f]
     }
     close $f
     set f [open $hfile w ]
     foreach curip $ipList {
     set ncurip [string trimleft $curip " " ]
     if {[string first "case " $ncurip 0 ] >=0 && [string last ":;" $curip ] >=0 } {
        set curip [string trimright $curip ";" ]
     }
     if {[string first "// item" $ncurip 0 ] >=0 } {
        continue 
     }
     if {[string first "//" $ncurip 0 ] >=0 && [string last ";" $curip ] >=0 } {
        set curip [string trimright $curip ";" ]
     }
     if {[string first "if " $ncurip 0 ] >=0 && [string last ";" $curip ] >=0 } {
        set curip [string trimright $curip ";" ]
     }
     if {[string first "#" $ncurip 0 ] >=0 && [string last ";" $curip ] >=0 } {
        set curip [string trimright $curip ";" ]
     }
     if {[string trim $curip " " ] == ";" } {
        continue 
     }
     if {[string trim $curip " " ] == "\};" } {
        set curip [string trimright $curip ";" ]
     }
     if {[string last ",;" $curip ] >=0 } {
        set curip [string trimright $curip ";" ]
     }
    
    
     puts $f $curip  
     }
     close $f
   #item 93
    if {$error_message != ""} {
        #item 96
        error $error_message
    } else {
	#set tail $filename
	set tail $hfile
	set last [ string last "." $tail ]

	set cut_tail [ string range $tail 0 $last ]
        file delete -force -- $cut_tail     # удалить непустую папку
#	exec start.exe $hfile
	set command "[auto_execok start] {} [list $hfile]"
	if { $command == {} } { return }
	if { [ catch {exec {*}$command &} err ] } {
	  tk_messageBox -icon error -message "error '$err' with\n'$command'"
	}

  }
}

proc generate_body { gdb diagram_id start_item node_list sorted incoming } {
    #item 26
    set callbacks [ make_callbacks ]
    	return [ cbody::generate_body $gdb $diagram_id $start_item $node_list \
    		$sorted $incoming $callbacks ]
}

proc make_callbacks { } {
    #item 20
    set cbks [ gen_java::make_callbacks ]
    set cbks [ dict replace $cbks signature gen_openscad::extract_signature ]
    set cbks [ dict replace $cbks body gen_openscad::generate_body ]
    #gen::put_callback cbks if_close  gen_java::block_close

    #gen::put_callback cbks loopstart  gen_openscad::loopstart


	return $cbks
} 

proc newline_cut { texttrans } {
    set texttrans [ string map {"\n"   " "} $texttrans ]
    set texttrans [ string map {"                "  " "} $texttrans ]
    set texttrans [ string map {"        "  " "} $texttrans ]
    set texttrans [ string map {"    "  " "} $texttrans ]
    set texttrans [ string map {"  "  " "} $texttrans ]
    set texttrans [ string map {"  "  " "} $texttrans ]
    set texttrans [ string map {"  "  " "} $texttrans ]
    set texttrans [ string trimleft $texttrans ]
    set texttrans [ string trimright $texttrans ]
    return $texttrans
}

proc digit_cut { texttrans } {
    set texttrans [ string map {" "  ""} $texttrans ]
    set texttrans [ string map {"0"  ""} $texttrans ]
    set texttrans [ string map {"1"  ""} $texttrans ]
    set texttrans [ string map {"2"  ""} $texttrans ]
    set texttrans [ string map {"3"  ""} $texttrans ]
    set texttrans [ string map {"4"  ""} $texttrans ]
    set texttrans [ string map {"5"  ""} $texttrans ]
    set texttrans [ string map {"6"  ""} $texttrans ]
    set texttrans [ string map {"7"  ""} $texttrans ]
    set texttrans [ string map {"8"  ""} $texttrans ]
    set texttrans [ string map {"9"  ""} $texttrans ]
    set texttrans [ string map {","  ""} $texttrans ]
    set texttrans [ string map {"."  ""} $texttrans ]
    set texttrans [ string map {"-"  ""} $texttrans ]
    return $texttrans
}

proc nodigit_cut { text } {
    tk_messageBox -message "text: $text"
    set no_dig_text [ digit_cut $text ]
    tk_messageBox -message "no_dig_text: $no_dig_text : $text"
    set text [ string map {$no_dig_text  ""} $text ]
    tk_messageBox -message "text: $text"
    set text [ string map {" "  ""} $text ]
    tk_messageBox -message "text::: $text"
    return $text
}

proc newline_cut_to { texttrans } {
    set texttrans [ string map {";\n"   " "} $texttrans ]
    return $texttrans
}

proc my_name_translit { texttrans } {

    set texttrans [ string map {"?"   ""} $texttrans ]

    set texttrans [ string map {"                "  " "} $texttrans ]
    set texttrans [ string map {"        "  " "} $texttrans ]
    set texttrans [ string map {"    "  " "} $texttrans ]
    set texttrans [ string map {"  "  " "} $texttrans ]
    set texttrans [ string map {"  "  " "} $texttrans ]
    set texttrans [ string map {"  "  " "} $texttrans ]
    set texttrans [ string map {" ("   "("} $texttrans ]
    set texttrans [ string map {" )"   ")"} $texttrans ]
    set texttrans [ string map {" \n"   "\n"} $texttrans ]
    set texttrans [ string map {" ;"   ";"} $texttrans ]
    set texttrans [ string trimleft     $texttrans]
    set texttrans [ string trimright    $texttrans]
    set texttrans [ string map {" "   "_"} $texttrans ]
    set texttrans [ string map {"_("   "("} $texttrans ]

    set texttrans [ string map {"(function)"  "function "} $texttrans ]
    set texttrans [ string map {"(байт)"  "byte "} $texttrans ]
    set texttrans [ string map {"(цел)"   "int "} $texttrans ]
    set texttrans [ string map {"(вещ)"   "double " } $texttrans ]
    set texttrans [ string map {"(лог)"   "boolean " } $texttrans ]
    set texttrans [ string map {"(сим)"   "char "   } $texttrans ]
    set texttrans [ string map {"(лит)"   "char* "  } $texttrans ]
    set texttrans [ string map {"(стр)"   "String " } $texttrans ]
    set texttrans [ string map {"(конст)" "const "  } $texttrans ]

    set texttrans [ string map {"(byte)"  "byte "} $texttrans ]
    set texttrans [ string map {"(int)"   "int "} $texttrans ]
    set texttrans [ string map {"(double)"  "double " } $texttrans ]
    set texttrans [ string map {"(long)"  "long " } $texttrans ]
    set texttrans [ string map {"(boolean)" "boolean " } $texttrans ]
    set texttrans [ string map {"(char)"   "char "   } $texttrans ]
    set texttrans [ string map {"(char*)"  "char* "  } $texttrans ]
    set texttrans [ string map {"(String)" "String " } $texttrans ]
    set texttrans [ string map {"(const)" "const "  } $texttrans ]

    set texttrans [ string map {"+"   "_plus_"} $texttrans ]
    set texttrans [ string map {"-"   "_minus_"} $texttrans ]
    set texttrans [ string map {"*"   "_star_"} $texttrans ]
    set texttrans [ string map {"/"   "_slash_"} $texttrans ]
    set texttrans [ string map {"%"   "_perc_"} $texttrans ]

    set texttrans [ string map {" _"   " "} $texttrans ]
    # Костыли, нужно будет исправить
    #set texttrans [ string map {"\)\(\)"   "\)" } $texttrans ]
    set texttrans [ string map {"_==_"   " == " } $texttrans ]
    set texttrans [ string map {"_>_"   " > " } $texttrans ]
    set texttrans [ string map {"_<_"   " < " } $texttrans ]

    return $texttrans
}

proc mytranslit { texttrans } {
    #item 102
    #if {[string first "байт "       $texttrans] == 0} {set texttrans [ string map {"байт "   "byte "} $texttrans ]}
    #if {[string first "цел "        $texttrans] == 0} {set texttrans [ string map {"цел "   "int "} $texttrans ]}
    #if {[string first "вещ "        $texttrans] == 0} {set texttrans [ string map {"вещ "   "double "} $texttrans ]}
    #if {[string first "лог "        $texttrans] == 0} {set texttrans [ string map {"лог "   "boolean "} $texttrans ]}
    #if {[string first "сим "        $texttrans] == 0} {set texttrans [ string map {"сим "   "char "} $texttrans ]}
    #if {[string first "лит "        $texttrans] == 0} {set texttrans [ string map {"лит "   "char* "} $texttrans ]}
    #if {[string first "стр "        $texttrans] == 0} {set texttrans [ string map {"стр "   "String "} $texttrans ]}
    #if {[string first "конст "      $texttrans] == 0} {set texttrans [ string map {"конст " "const "} $texttrans ]}
    #if {[string first "беззнака "   $texttrans] == 0} {set texttrans [ string map {"беззнака "   "unsigned "} $texttrans ]}

    set texttrans [ string map {" байт "   " byte "} $texttrans ]
    set texttrans [ string map {" цел "   " int "} $texttrans ]
    set texttrans [ string map {" вещ "   " double " } $texttrans ]
    set texttrans [ string map {" лог "   " boolean " } $texttrans ]
    set texttrans [ string map {" сим "   " char "   } $texttrans ]
    set texttrans [ string map {" лит "   " char* "  } $texttrans ]
    set texttrans [ string map {" стр "   " String " } $texttrans ]
    set texttrans [ string map {" конст " " const "  } $texttrans ]
    set texttrans [ string map {" беззнака " " unsigned " } $texttrans ]

    set texttrans [ string map {"\nбайт "  "\nbyte "} $texttrans ]
    set texttrans [ string map {"\nцел "   "\nint "} $texttrans ]
    set texttrans [ string map {"\nвещ "   "\ndouble " } $texttrans ]
    set texttrans [ string map {"\nлог "   "\nboolean " } $texttrans ]
    set texttrans [ string map {"\nсим "   "\nchar "   } $texttrans ]
    set texttrans [ string map {"\nлит "   "\nchar* "  } $texttrans ]
    set texttrans [ string map {"\nстр "   "\nString " } $texttrans ]
    set texttrans [ string map {"\nконст " "\nconst "  } $texttrans ]
    set texttrans [ string map {"\nбеззнака " "\nunsigned " } $texttrans ]

    set texttrans [ string map {"\(байт "  "\(byte "} $texttrans ]
    set texttrans [ string map {"\(цел "   "\(int "} $texttrans ]
    set texttrans [ string map {"\(вещ "   "\(double " } $texttrans ]
    set texttrans [ string map {"\(лог "   "\(boolean " } $texttrans ]
    set texttrans [ string map {"\(сим "   "\(char "   } $texttrans ]
    set texttrans [ string map {"\(лит "   "\(char* "  } $texttrans ]
    set texttrans [ string map {"\(стр "   "\(String " } $texttrans ]
    set texttrans [ string map {"\(конст " "\(const "  } $texttrans ]
    set texttrans [ string map {"\(беззнака " "\(unsigned " } $texttrans ]

    set texttrans [ string map {",байт "  ",byte "} $texttrans ]
    set texttrans [ string map {",цел "   ",int "} $texttrans ]
    set texttrans [ string map {",вещ "   ",double " } $texttrans ]
    set texttrans [ string map {",лог "   ",boolean " } $texttrans ]
    set texttrans [ string map {",сим "   ",char "   } $texttrans ]
    set texttrans [ string map {",лит "   ",char* "  } $texttrans ]
    set texttrans [ string map {",стр "   ",String " } $texttrans ]
    set texttrans [ string map {",конст " ",const "  } $texttrans ]
    set texttrans [ string map {",беззнака " ",unsigned " } $texttrans ]

    set texttrans [ string map {"вернуть " "return " } $texttrans ]
    set texttrans [ string map {":=" "=" } $texttrans ]
    set texttrans [ string map {"\n" ";\n"  } $texttrans ]

    set texttrans [ string map {"== >"   ">"} $texttrans ]
    set texttrans [ string map {"== <"   "<"} $texttrans ]
    set texttrans [ string map {"== <="   "<="} $texttrans ]
    set texttrans [ string map {"== =<"   "=<"} $texttrans ]
    set texttrans [ string map {"== >="   ">="} $texttrans ]
    set texttrans [ string map {"== =>"   "=>"} $texttrans ]

    set texttrans [ string map {"; ;"   ";"} $texttrans ]
    set texttrans [ string map {";;" ";"} $texttrans ]
    set texttrans [ string map {"\{;"   "\{"   } $texttrans ]
    set texttrans [ string map {"throw new IllegalStateException" "\/\/ illegal code "} $texttrans ]

    set texttrans [ string map {й j ц c у u к k е e н n г g ш sh щ szh з z х h ъ x} $texttrans ]
    set texttrans [ string map {ф f ы y в v а a п p р r о o л l  д d   ж zh э ae} $texttrans ]
    set texttrans [ string map {я ja ч ch с s м m и i т t ь j б b ю ju ё jo } $texttrans ]
    set texttrans [ string map {Й J Ц C У U К K Е E Н N Г G Ш SH Щ SZH З Z Х H Ъ X} $texttrans ]
    set texttrans [ string map {Ф F Ы Y В V А A П P Р R О O Л L Д D Ж ZH Э AE} $texttrans ]
    set texttrans [ string map {Я JA Ч CH С S М M И I Т T Ь J Б B Ю JU Ё JO } $texttrans ]
    return $texttrans
}
proc mytranslit_declaration { texttrans } {
    #if {[string first "байт "       $texttrans] == 0} {set texttrans [ string map {"байт "   "byte "} $texttrans ]}
    #if {[string first "цел "        $texttrans] == 0} {set texttrans [ string map {"цел "   "int "} $texttrans ]}
    #if {[string first "вещ "        $texttrans] == 0} {set texttrans [ string map {"вещ "   "double "} $texttrans ]}
    #if {[string first "лог "        $texttrans] == 0} {set texttrans [ string map {"лог "   "boolean "} $texttrans ]}
    #if {[string first "сим "        $texttrans] == 0} {set texttrans [ string map {"сим "   "char "} $texttrans ]}
    #if {[string first "лит "        $texttrans] == 0} {set texttrans [ string map {"лит "   "char* "} $texttrans ]}
    #if {[string first "стр "        $texttrans] == 0} {set texttrans [ string map {"стр "   "String "} $texttrans ]}
    #if {[string first "конст "      $texttrans] == 0} {set texttrans [ string map {"конст " "const "} $texttrans ]}
    #if {[string first "беззнака "   $texttrans] == 0} {set texttrans [ string map {"беззнака "   "unsigned "} $texttrans ]}

    set texttrans [ string map {" байт "   " byte "} $texttrans ]
    set texttrans [ string map {"\ цел "   " int "} $texttrans ]
    set texttrans [ string map {" вещ "   " double " } $texttrans ]
    set texttrans [ string map {" лог "   " boolean " } $texttrans ]
    set texttrans [ string map {" сим "   " char "   } $texttrans ]
    set texttrans [ string map {" лит "   " char* "  } $texttrans ]
    set texttrans [ string map {" стр "   " String " } $texttrans ]
    set texttrans [ string map {" конст " " const "  } $texttrans ]
    set texttrans [ string map {" беззнака " " unsigned " } $texttrans ]

    set texttrans [ string map {"\nбайт "  "\nbyte "} $texttrans ]
    set texttrans [ string map {"\nцел "   "\nint "} $texttrans ]
    set texttrans [ string map {"\nвещ "   "\ndouble " } $texttrans ]
    set texttrans [ string map {"\nлог "   "\nboolean " } $texttrans ]
    set texttrans [ string map {"\nсим "   "\nchar "   } $texttrans ]
    set texttrans [ string map {"\nлит "   "\nchar* "  } $texttrans ]
    set texttrans [ string map {"\nстр "   "\nString " } $texttrans ]
    set texttrans [ string map {"\nконст " "\nconst "  } $texttrans ]
    set texttrans [ string map {"\nбеззнака " "\nunsigned " } $texttrans ]

    #set texttrans [ string map {"Настройка" "setup" } $texttrans ]
    #set texttrans [ string map {"Программа" "loop" } $texttrans ]

    set texttrans [ string map {й j ц c у u к k е e н n г g ш sh щ szh з z х h ъ x} $texttrans ]
    set texttrans [ string map {ф f ы y в v а a п p р r о o л l  д d   ж zh э ae} $texttrans ]
    set texttrans [ string map {я ja ч ch с s м m и i т t ь j б b ю ju ё jo } $texttrans ]
    set texttrans [ string map {Й J Ц C У U К K Е E Н N Г G Ш SH Щ SZH З Z Х H Ъ X} $texttrans ]
    set texttrans [ string map {Ф F Ы Y В V А A П P Р R О O Л L Д D Ж ZH Э AE} $texttrans ]
    set texttrans [ string map {Я JA Ч CH С S М M И I Т T Ь J Б B Ю JU Ё JO } $texttrans ]
    return $texttrans
}

proc normalize_for { var start end } {
    #item 62
    return "delay ();"
}

proc p.print_to_file { fhandle functions header footer use_nogoto } {
    #item 86
    variable prog_head
    variable prog_loop
    variable prog_setup
    set version [ version_string ]
    puts $fhandle \
        "// Autogenerated with DRAKON Editor $version "
    puts $fhandle \
        "// Generator adopted by Bardynin Dmitry, Astrakhan-Sochi, 2015-2019, ver.0.11"
    
    puts $fhandle " "
    if { $header != "" } {
    	set header [ mytranslit $header ]
    	puts $fhandle $header
    }
        
        foreach function $functions {
        	unpack $function diagram_id name signature body
        set name [ newline_cut $name ]
        set type [ lindex $signature 0 ]
            if  {$type != "comment" } {
                if  {$name eq $gen_openscad::prog_head} {
         		    puts $fhandle "\n\/\/[ mytranslit_declaration $name]"
        		    set lines [ gen::indent $body 1 ]
        		    set lines [ mytranslit $lines ]
        		    append lines ";"
            		puts $fhandle $lines
            		puts $fhandle ""
            	}
            }
        }

        set ready 0
        foreach function $functions {
        	unpack $function diagram_id name signature body
            set name [ newline_cut $name ]
            set type [ lindex $signature 0 ]
            if  {$type != "comment" } {
                if  {$name eq $gen_openscad::prog_setup} {
                    set ready 1
                    puts $fhandle "\n\/\/ [mytranslit_declaration $name]"
            		#set declaration [ build_declaration $name $signature ]
                    set declaration [ build_declaration "setup" $signature ]
                    set declaration [ mytranslit_declaration $declaration ]
                    puts $fhandle $declaration
        		    set lines [ gen::indent $body 1 ]
        		    append lines ";"
        		    set lines [ mytranslit $lines ]
            		puts $fhandle $lines
            		puts $fhandle "\}"
            	}
            }
        }
        if {$ready == 0} {
            #puts $fhandle "\nvoid setup () \{\}"
        }
    #    set ready 0
    #   foreach function $functions {
    #       	unpack $function diagram_id name signature body
    #        set name [ newline_cut $name ]
    #        set type [ lindex $signature 0 ]
    #       	if  {$type != "comment" } {
    #            if  {$name eq $gen_openscad::prog_loop} {
    #                set ready 1
    #                puts $fhandle "\n\/\/[ mytranslit_declaration $name]"
            		#set declaration [ build_declaration $name $signature ]
    #                set declaration [ build_declaration "loop" $signature ]
    #        		set declaration [ mytranslit_declaration $declaration ]
    #        		puts $fhandle $declaration
    #        		set lines [ gen::indent $body 1 ]
    #        		append lines ";"
    #        		set lines [ mytranslit $lines ]
    #        		puts $fhandle $lines
    #        		puts $fhandle "\}"
    #        	}
    # 	    }
    #    }
    #    if {$ready == 0} {
    #        puts $fhandle "\nvoid loop () \{\}"
    #    }

        foreach function $functions {
           	unpack $function diagram_id name signature body
            set name [ newline_cut $name ]
            set type [ lindex $signature 0 ]
            if  {$type != "comment"
                     &&  $name !=$prog_loop
                     &&  $name !=$prog_head
                     &&  $name !=$prog_setup} {
            	puts $fhandle ""
#############################
			    set name [ my_name_translit $name ]
#############################
            	set declaration [ build_declaration $name $signature ]
            	set declaration [ mytranslit_declaration $declaration ]
                set function_present 0
                if {[string first "function" $declaration 0 ] >=0 } {
                    set declaration "[string trimright $declaration "\{" ] ="
                    set function_present 1
                }
                     
            	puts $fhandle $declaration
                #tk_messageBox -icon info -message "$fhandle \n $declaration"
            	set lines [ gen::indent $body 1 ]
            	append lines ";"
            	set lines [ mytranslit $lines ]
            	puts $fhandle $lines
            	if { $function_present == 0 } { puts $fhandle "\}" }
            }
        }
    puts $fhandle ""
    set footer [ mytranslit $footer ]
    puts $fhandle $footer
}

proc parse_for { item_id text } {
    #item 56
        set tokens [ to_tokens $text ]
    #log "token >>> $tokens"
    #log "text  >>> $text"
        if {[ llength $tokens ] < 6} {
    #        error "<6 Wrong 'for' syntax in item $item_id"
        } else {
            unpack $tokens for var eq start comma
            if {(($for == "for") && ($eq == "=")) && ($comma == ",")} {
                set comma_index [ string first "," $text ]
                set target_index [ expr { $comma_index + 1 } ]
                set target [ string range $text $target_index end ]
                set end [ string trim $target ]
                return [ list $var $start $end ]
            } else {
    #            error "?? Wrong 'for' syntax in item $item_id"
            }
        }
}

proc rewire_wiring_pause { gdb diagram_id } {
	  # item 32
	  set starts [ $gdb eval {
	    select vertex_id
	    from vertices
	    where type = 'pause'
	    and right = ''
	    and diagram_id = :diagram_id } ]
	  set _col1734 $starts
	  set _len1734 [ llength $_col1734 ]
	  set _ind1734 0
	  while { 1 } {
	    if {$_ind1734 < $_len1734} {
	      } else { break }
	    set vertex_id [ lindex $_col1734 $_ind1734 ]
	    unpack [ $gdb eval {
	    select text, item_id
	    from vertices
	    where vertex_id = :vertex_id
	    } ] text item_id

        set s1 [string first "жди " [string tolower $text] ]
        #tk_messageBox -message "text !$text!s1!$s1![string tolower $text]"
        if { $s1 == 0 } {
            #set text [string tolower $text]
            #set text [string trimleft $text "жди "]
            set text [string range $text 4 end]
            set text [ newline_cut $text ]
            set new_text "while(!\($text)) {}  // wait \"$text\""
        } else {
            if { [ convert2msec $text ] != "" } {
	               set new_text "delay([ convert2msec $text ]); //pause $text"
	        } else {
	               #graph::p.error $diagram_id [ list $item_id ] "Pause: Некорректное указание единиц измерения: [digit_cut $text ]"
                   #set new_text "while($text) {}  // pause \"$text\""
                   set new_text "delay( $text ); //pause $text"
	        }
        }

	    $gdb eval {
	      update vertices
	      set text = :new_text
	      where vertex_id = :vertex_id
	    }
	    incr _ind1734
	  }
	}

proc rewire_wiring_pause_ins { gdb diagram_id } {
	  # item 32
      lassign [ gdb eval { select type, text from vertices where vertex_id = :current } ] type text
	  set starts [ $gdb eval {
	    select vertex_id
	    from vertices
	    where type = 'pause'
	    and up != ''
	    and right != ''
	    and diagram_id = :diagram_id } ]
	  set _col1734 $starts
	  set _len1734 [ llength $_col1734 ]
	  set _ind1734 0
	  while { 1 } {
	    if {$_ind1734 < $_len1734} {
	      } else { break }
	    set vertex_id [ lindex $_col1734 $_ind1734 ]
	    unpack [ $gdb eval {
	    select text, item_id, right
	    from vertices
	    where vertex_id = :vertex_id
	    } ] text item_id right

	    # tk_messageBox -message "text !$text!$item_id!$right!text item_id right"

	    set time_ins ""
	    if { $right != "" } {
	      lassign [ $gdb eval {
	        select text, type
	        from vertices
	        where left = :right } ] time_ins type_ins
	         #tk_messageBox -message "type_ins $type_ins "
	      }

        if { $type_ins=="action"} {
            if { [ convert2msec $text ] == "" } {
	            #graph::p.error $diagram_id [ list $item_id ] "Pause_Insertion: Некорректное указание единиц измерения: [digit_cut $text ]"
                set new_text "unsigned long delay_$item_id = millis();\n\
	            while\( $text ) \{ \n$time_ins; \n\}  // delay($text); // pause + action   "
	        } else {
	            set new_text "unsigned long delay_$item_id = millis();\n\
	            while\(\(millis\()-delay_$item_id) < [ convert2msec $text ]) \{\n $time_ins; \n\}  "
            }
        } else {
            set time_ins [join [ newline_cut $time_ins ]]

	        if { [ is_dia_name $time_ins $gdb] != 1 } {
	            graph::p.error $diagram_id [ list $item_id ] "Диаграмма \"$time_ins\" не найдена"
	        }
            set s1 [string last "\(" $time_ins ]
            if { $s1 > 0 } {
                graph::p.error $diagram_id [ list $item_id ] "Вставка \"$time_ins\" не может содержать аргументы"
            }
            set time_ins [ my_name_translit $time_ins ]
	        # set timer [compress $timer]
	        if { [ convert2msec $text ] == "" } {
	            #graph::p.error $diagram_id [ list $item_id ] "Pause_Insertion: Некорректное указание единиц измерения: [digit_cut $text ]"
                set new_text "unsigned long delay_$item_id = millis();\n\
	            while\( $text ) \{ $time_ins\(); \}  // delay($text); // pause + insertion   "
	        } else {
	            set new_text "unsigned long delay_$item_id = millis();\n\
	            while\(\(millis\()-delay_$item_id) < [ convert2msec $text ]) \{ $time_ins\(); \}  "
            }
        }
	    # set new_text "// delay($text); // pause + insertion "

	    $gdb eval {
	      update vertices
	      set text = :new_text
	      where vertex_id = :vertex_id
	    }
	    incr _ind1734
	  }
	}

    proc rewire_wiring_input { gdb diagram_id } {
        #item 50
        set starts [ $gdb eval {
        	select vertex_id
        	from vertices
        	where type = 'input'
    		and diagram_id = :diagram_id } ]
	    set _col1734 $starts
	    set _len1734 [ llength $_col1734 ]
	    set _ind1734 0
	    while { 1 } {
	        if {$_ind1734 < $_len1734} {
            } else { break }
            set vertex_id [ lindex $_col1734 $_ind1734 ]
            unpack [ $gdb eval {
        	    select text, text2, item_id
        	    from vertices
        	    where vertex_id = :vertex_id
            } ] text text2 item_id
    #########################
	        set text2 [ join [ newline_cut $text2 ] ]
            set s1 [string first "\(" $text2]
            if { [ is_dia_name $text2 $gdb] != 1 } {
               graph::p.error $diagram_id [ list $item_id ] "Диаграмма \"$text2\" не найдена"
            }
           #tk_messageBox -message "text2 $text2 "
	        set text2 [ my_name_translit $text2 ]
        #tk_messageBox -message "text2 $text2 "
	    #set a [split $text2 " "]
	    #if {[lindex $a 1] != ""} {set text2 [lindex $a 1] }
    # Проверить корректность в именах
    #########################
            set exper [string last ")" $text2]
            if {$exper < 0} { set new_text "$text = $text2\(); // input without parameter"
                } else { set new_text "$text = $text2; // input with parameter" }
            $gdb eval {
        	    update vertices
        	    set text = :new_text
        	    where vertex_id = :vertex_id
            }
            incr _ind1734
        }
    }

    proc rewire_wiring_input_simple { gdb diagram_id } {
        #item 50
        set starts [ $gdb eval {
        	select vertex_id
        	from vertices
        	where type = 'input_simple'
        	and diagram_id = :diagram_id } ]
        set _col1734 $starts
        set _len1734 [ llength $_col1734 ]
        set _ind1734 0
        while { 1 } {
            if {$_ind1734 < $_len1734} {
            } else { break }
            set vertex_id [ lindex $_col1734 $_ind1734 ]
            unpack [ $gdb eval {
            	select text, text2, item_id
            	from vertices
            	where vertex_id = :vertex_id
                 } ] text text2 item_id
            set new_text "$text = Serial.read(); // input_simple"
            $gdb eval {
            	update vertices
            	set text = :new_text
            	where vertex_id = :vertex_id
            }
            incr _ind1734
        }
    }

proc rewire_wiring_insertion { gdb diagram_id } {
	#item 38
	set starts [ $gdb eval {
	    select vertex_id
	    from vertices
	    where type = 'insertion'
	    and up != ''
	    and diagram_id = :diagram_id } ]
	set _col1734 $starts
	set _len1734 [ llength $_col1734 ]
	set _ind1734 0
	while { 1 } {
	    if {$_ind1734 < $_len1734} {
	    } else { break }
	    set vertex_id [ lindex $_col1734 $_ind1734 ]
	    unpack [ $gdb eval {
	      select text, item_id, left
	      from vertices
	      where vertex_id = :vertex_id
	      } ] text item_id left

	    set text [ join [ newline_cut $text ] ]
	    if { [ is_dia_name $text $gdb] != 1 } {
	        graph::p.error $diagram_id [ list $item_id ] "Диаграмма \"$text\" не найдена"
	    }
        set s1 [string last "\(" $text ]
        if { $s1 > 0 } {
            graph::p.error $diagram_id [ list $item_id ] "Вставка \"$text\" не может содержать аргументы"
        }

	    set text [ my_name_translit $text ]
	    #set a [split $text " "]
	    #if {[lindex $a 1] != ""} {set text [lindex $a 1] }
	    #########################
	    set timer ""
	    if { $left != "" } {
	      	set timer [ $gdb eval {
	        	select text
	        	from vertices
	        	where right = :left  } ]
	        # tk_messageBox -message "timer $timer "
	    }
	    set timer [compress $timer]
	    if {$timer != ""} {
            set stimer [ string map {"=="   "="} $timer ]
	        set val [split $stimer "="]
            set time [lindex $val 1 ]

  	        if { [ convert2msec $time ] == "" } {
    	        #graph::p.error $diagram_id [ list $item_id ] "Insertion: Некорректное указание единиц измерения: [digit_cut $time ]"
                set new_text "//Synchronizer by rule: $timer ; \nwhile \(!($timer)) { delay(1); } \n  $text\(); // insertion"
	        } else {
	            # tk_messageBox -message "llength val [llength $val] "
	            if { [llength $val] != 2 } {graph::p.error $diagram_id [ list $item_id ] "Ошибка в целевом значении таймера: $timer"}
  	            set new_text "//Synchronizer by timer: $timer ; \nwhile \(millis\()-_timer_[lindex $val 0] < [convert2msec $time]) {} \n  $text\(); // insertion"
            }
	    } else {
	    	set new_text "$text\(); // insertion"
	    }
	    $gdb eval {
	      	update vertices
	      	set text = :new_text
	      	where vertex_id = :vertex_id
	    }
	    incr _ind1734
	}
}

proc rewire_wiring_timer { gdb diagram_id } {
	  #item 38
	  set starts [ $gdb eval {
	    select vertex_id
	    from vertices
	    where type = 'timer'
	    and diagram_id = :diagram_id } ]
	  set _col1734 $starts
	  set _len1734 [ llength $_col1734 ]
	  set _ind1734 0
	  while { 1 } {
	    if {$_ind1734 < $_len1734} {
	      } else { break }
	    set vertex_id [ lindex $_col1734 $_ind1734 ]
	    unpack [ $gdb eval {
	      select text, item_id
	      from vertices
	      where vertex_id = :vertex_id
	      } ] text item_id
	    set text [compress $text]
	    set val [split $text "="]
	    set time [ convert2msec [lindex $val 1 ] ]
	    set text "[lindex $val 0]=$time"
	    if { $time == "" } {
	      graph::p.error $diagram_id [ list $item_id ] "Timer: Некорректное указание единиц измерения: [digit_cut $text ]"
	    }

	    if { [llength $val] != 2 } {graph::p.error $diagram_id [ list $item_id ] "Ошибка в определении значения таймера."}
	    set new_text "_timer_$text + millis\(); // Set timer $text"
	    $gdb eval {
	      update vertices
	      set text = :new_text
	      where vertex_id = :vertex_id
	    }
	    incr _ind1734
	  }
	}


    proc rewire_wiring_output { gdb diagram_id } {
    	  #item 44
    	  set starts [ $gdb eval {
    	    select vertex_id
    	    from vertices
    	    where type = 'output'
    	    and diagram_id = :diagram_id } ]
    	  set _col1734 $starts
    	  set _len1734 [ llength $_col1734 ]
    	  set _ind1734 0
    	  while { 1 } {
    	    if {$_ind1734 < $_len1734} {
    	      } else { break }
    	    set vertex_id [ lindex $_col1734 $_ind1734 ]
    	    unpack [ $gdb eval {
    	      select text, text2, item_id, left
    	      from vertices
    	      where vertex_id = :vertex_id
    	      } ] text text2 item_id left
    	    #########################
    	    set text2 [ join [ newline_cut $text2 ] ]
    	    if { [ is_dia_name $text2 $gdb] != 1 } {
    	      graph::p.error $diagram_id [ list $item_id ] "Диаграмма \"$text2\" не найдена"
    	    }
    	    set text2 [ my_name_translit $text2 ]
    	    if {$text2 == ""} {set text2 "Serial.print" }
    	    #set a [split $text2 " "]
    	    #if {[lindex $a 1] != ""} {set text2 [lindex $a 1] }
    	    #########################
    	    set timer ""
    	    if { $left != "" } {
    	      set timer [ $gdb eval {
    	        select text
    	        from vertices
    	        where right = :left  } ]
    	        # tk_messageBox -message "timer $timer "
    	    }
    	    if {$timer != ""} {
    	      set timer [compress $timer]
    	      set val [split $timer "="]
    	      set time [lindex $val 1 ]
    	      if { [ convert2msec $time ] == "" } {
    	        graph::p.error $diagram_id [ list $item_id ] "Output: Некорректное указание единиц измерения: [digit_cut $timer ]"
    	      }
    	      # tk_messageBox -message "llength val [llength $val] "
    	      if { [llength $val] != 2 } {
    	        graph::p.error $diagram_id [ list $item_id ] "Output: Ошибка в целевом значении таймера: $timer "
    	      }
    	      set new_text "//Synchronizer by timer $timer ; \nwhile \(millis\()-_timer_[lindex $val 0] < [ convert2msec $time ]) { } \n$text2\($text); // output"
    	    } else {
    	      set new_text "$text2\([newline_cut $text]); // output"
    	    }
    	    $gdb eval {
    	      update vertices
    	      set text = :new_text
    	      where vertex_id = :vertex_id
    	    }
    	    incr _ind1734
    	  }
    	}

        proc rewire_wiring_output_simple { gdb diagram_id } {
        	  #item 44
        	  set starts [ $gdb eval {
        	    select vertex_id
        	    from vertices
        	    where type = 'output_simple'
        	    and diagram_id = :diagram_id } ]
        	  set _col1734 $starts
        	  set _len1734 [ llength $_col1734 ]
        	  set _ind1734 0
        	  while { 1 } {
        	    if {$_ind1734 < $_len1734} {
        	      } else { break }
        	    set vertex_id [ lindex $_col1734 $_ind1734 ]
        	    unpack [ $gdb eval {
        	      select text, text2, item_id, left
        	      from vertices
        	      where vertex_id = :vertex_id
        	      } ] text text2 item_id left
        	    #########################
        	    set text2 "Serial.print"
        	    #set a [split $text2 " "]
        	    #if {[lindex $a 1] != ""} {set text2 [lindex $a 1] }
        	    #########################
        	    set timer ""
        	    if { $left != "" } {
        	      set timer [ $gdb eval {
        	        select text
        	        from vertices
        	        where right = :left  } ]
        	        # tk_messageBox -message "timer $timer "
        	    }
        	    if {$timer != ""} {
        	      set timer [compress $timer]
        	      set val [split $timer "="]
        	      set time [lindex $val 1 ]
        	      if { [ convert2msec $time ] == "" } {
        	        graph::p.error $diagram_id [ list $item_id ] "Output: Некорректное указание единиц измерения: [digit_cut $timer ]"
        	      }
        	      # tk_messageBox -message "llength val [llength $val] "
        	      if { [llength $val] != 2 } {
        	        graph::p.error $diagram_id [ list $item_id ] "Output: Ошибка в целевом значении таймера: $timer "
        	      }
        	      set new_text "//Synchronizer by timer $timer ; \nwhile \(millis\()-_timer_[lindex $val 0] < [ convert2msec $time ]) { } \n$text2\($text); // output_simple"
        	    } else {
        	      set new_text "$text2\([newline_cut $text]); // output_simple"
        	    }
        	    $gdb eval {
        	      update vertices
        	      set text = :new_text
        	      where vertex_id = :vertex_id
        	    }
        	    incr _ind1734
        	  }
        	}

proc rewire_wiring_process { gdb diagram_id } {
    set starts [ $gdb eval {
       	select vertex_id
       	from vertices
       	where type = 'process'
    	and diagram_id = :diagram_id } ]
    set _col1734 $starts
    set _len1734 [ llength $_col1734 ]
    set _ind1734 0
    while { 1 } {
        if {$_ind1734 < $_len1734} {
        } else { break }
    	set vertex_id [ lindex $_col1734 $_ind1734 ]
    	unpack [ $gdb eval {
          	select text, text2, item_id
          	from vertices
           	where vertex_id = :vertex_id
            } ] text text2 item_id
	    set text [ my_name_translit $text ]
        set new_text "$text\($text2); // process \& command"
        $gdb eval {
          	update vertices
           	set text = :new_text
           	where vertex_id = :vertex_id
        }
        incr _ind1734
    }
}

proc rewire_wiring_if { gdb diagram_id } {
    set starts [ $gdb eval {
       	select vertex_id
       	from vertices
       	where type = 'if'
    	and diagram_id = :diagram_id } ]
    set _col1734 $starts
    set _len1734 [ llength $_col1734 ]
    set _ind1734 0
    while { 1 } {
        if {$_ind1734 < $_len1734} {
        } else { break }
    	set vertex_id [ lindex $_col1734 $_ind1734 ]
    	unpack [ $gdb eval {
          	select text, text2, item_id
          	from vertices
           	where vertex_id = :vertex_id
            } ] text text2 item_id

        set new_text [ string map {"\?" ""} $text ]
        set new_text [ join [ newline_cut $new_text ] ]
        #tk_messageBox -icon info -message $new_text -title "$text"
        if { [ is_dia_name $new_text $gdb] != 1 } {
            set new_text "$new_text"
        } else {
            set s1 [string first ")" $new_text ]
            if {$s1 > 0  &&  [incr s1] < [string length $new_text ]} {
                graph::p.error $diagram_id [ list $item_id ] "If: [incr s1] [string length $new_text ] Использовано составное условие вместе с названием диаграммы. В данном генераторе этот вариант не обрабатывается."
            }
            set new_text  "[my_name_translit $new_text]()"
        }


        set new_text [ string map {")()"  ")"} $new_text ]

        $gdb eval {
          	update vertices
           	set text = :new_text
           	where vertex_id = :vertex_id
        }
        incr _ind1734
    }
}


proc rewire_wiring_loopstart { gdb diagram_id } {
    set starts [ $gdb eval { select vertex_id from vertices
       	where type = 'loopstart' and diagram_id = :diagram_id } ]
  	set _col1734 $starts
   	set _len1734 [ llength $_col1734 ]
   	set _ind1734 0
   	while { 1 } {
   	    if {$_ind1734 < $_len1734} {
        } else { break }
   	    set vertex_id [ lindex $_col1734 $_ind1734 ]
   	    unpack [ $gdb eval {
           	select text, text2, item_id
           	from vertices
           	where vertex_id = :vertex_id
        } ] text text2 item_id
		      set text [ join [ newline_cut $text ] ]
          set a [split $text "("]
          set a [string tolower $a]
          #tk_messageBox -icon info -message "'$a'" -title "'$text'"
          if { [lindex $a 0] == "повторить" || [lindex $a 0] == "repeat"} {
            if {[lindex $a 1] == ""} {
              set new_text "while(1)"
            } else {
              set a [lindex [split [lindex $a 1] ")"] 0 ]
              set new_text "for(int _rep$vertex_id=0; _rep$vertex_id<$a; _rep$vertex_id++)"
            }
          } elseif { [lindex $a 0] == "всегда"} {
              set new_text "while(1)"
          } elseif { [lindex $a 0] == "пока"} {
              set new_text [ string map {"пока" "while"  } $text ]
              #set new_text [ string map {"Пока" "while"  } $text ]
              #set new_text [ string map {"ПОКА" "while"  } $text ]
          } else {
            set new_text "$text"
          }
        $gdb eval {
          	update vertices set text = :new_text
           	where vertex_id = :vertex_id
        }
        incr _ind1734
    }
}

proc rewire_wiring_shelf { gdb diagram_id } {
    set starts [ $gdb eval { select vertex_id from vertices
       	where type = 'shelf' and diagram_id = :diagram_id } ]
  	set _col1734 $starts
   	set _len1734 [ llength $_col1734 ]
   	set _ind1734 0
   	while { 1 } {
   	    if {$_ind1734 < $_len1734} {
        } else { break }
   	    set vertex_id [ lindex $_col1734 $_ind1734 ]
   	    unpack [ $gdb eval {
           	select text, text2, item_id
           	from vertices
           	where vertex_id = :vertex_id
        } ] text text2 item_id
		set text [ newline_cut $text ]
        set new_text "$text2= $text; // shelf"
        $gdb eval {
          	update vertices set text = :new_text
           	where vertex_id = :vertex_id
        }
        incr _ind1734
    }
}

# Скомпоновать text & text2 в единый блок
proc rewire_wiring_rem2text { gdb diagram_id } {
    set starts [ $gdb eval { select vertex_id from vertices
      where type = 'action' and diagram_id = :diagram_id } ]
    lappend starts [ $gdb eval { select vertex_id from vertices
      where type = 'insertion' and diagram_id = :diagram_id } ]
    set _col1734 $starts
   	set _len1734 [ llength $_col1734 ]
   	set _ind1734 0
   	while { 1 } {
   	    if {$_ind1734 < $_len1734} {
        } else { break }
   	    set vertex_id [ lindex $_col1734 $_ind1734 ]
   	    unpack [ $gdb eval {
           	select text, text2, item_id
           	from vertices
           	where vertex_id = :vertex_id
        } ] text text2 item_id
		if { $text2 != "" } {
			set new_text "\/* $text2 *\/ \n$text"
		    $gdb eval {
          		update vertices set text = :new_text
           		where vertex_id = :vertex_id
			}
        }
        incr _ind1734
    }
}

# Проверяем все исполняющие блоки на изменение цвета, и комментим.
proc rewire_color { gdb diagram_id } {
	set db [ mwc::get_db ]
	set starts [ $gdb eval { select vertex_id from vertices
		where diagram_id = :diagram_id } ]
	set _col1734 $starts
	set _len1734 [ llength $_col1734 ]
	set _ind1734 0
	while { 1 } {
		if {$_ind1734 < $_len1734} {} else { break }
		set vertex_id [ lindex $_col1734 $_ind1734 ]
		unpack [ $gdb eval {
			select text, text2, item_id, type
			from vertices
			where vertex_id = :vertex_id
		} ] text text2 item_id type
		# Заодно проверим, есть ли пустые иконки

		if { $text == "" && $type != "" && $type != "case"   && $type != "action"  && $type != "loopend"} {
		  graph::p.error $diagram_id [ list $item_id ] "Пустые иконки при генерации запрещены. $type"
		}
		set my_names [ $db eval { SELECT color FROM items WHERE diagram_id = :diagram_id AND item_id = :item_id
			AND (type = "action" OR type = "pause" OR type = "insertion" OR type = "input" OR type = "output" OR type = "process" OR type = "shelf") } ]
		set lll [ llength [lindex $my_names 0] ]
		# если в позиции "цвета" что-то записано, то исключаем блок
		if { $lll > 0 } {
			set new_text "//$text; // changed color"
		} else {
			set new_text $text
		}
		$gdb eval {
			update vertices set text = :new_text
			where vertex_id = :vertex_id
		}
		incr _ind1734
	}
}

proc to_tokens { text } {
    #item 68
    set tokens [ search::to_tokens $text ]
    set result {}
    set _col1703 $tokens
    set _len1703 [ llength $_col1703 ]
    set _ind1703 0
    while { 1 } {
        if {$_ind1703 < $_len1703} {
        } else {
            break
        }
        set token [ lindex $_col1703 $_ind1703 ]
        set text [ lindex $token 0 ]
        set trimmed [ string trim $text ]
        if {$trimmed == ""} {
        } else {
            lappend result $text
        }
        incr _ind1703
    }
    return $result
}

proc is_dia_name { name gdb} {
    #tk_messageBox -icon info -message $name -title "$name"
    set s1 [string last "\(" $name ]
    if { $s1 > 0 } { set name [string range $name 0 $s1-1] }
    set name [string trimright $name]
    set name [string trimleft $name]
    set name [string map {"\?" ""} $name ]

    #set names [ $gdb eval {
    #    SELECT name FROM diagrams
    #  } ]
#SELECT name FROM diagrams WHERE name = :name
    set aaa $gen_openscad::correct
    #append aaa " " $names
    #tk_messageBox -icon info -message $aaa -title "$name"
    set right_names "\{"
    foreach names $aaa {
        append right_names [newline_cut $names] "\} \{"
    }
    append right_names "\}"

    set aaa $right_names
    #tk_messageBox -icon info -message $aaa -title "$name"
    foreach names $aaa {
        set s1 [string first ")" $names ]
        if { $s1 > 0 } { set names [string range $names $s1+1 end] }
        set names [string map {"\?" ""} $names ]
        set names [string trimleft $names]
        set names [string trimright $names]
        if { $names == $name } {
            #tk_messageBox -icon info -message "name:$name*" -title "names:$names*"
            return 1
        }
    }
    set names [ $gdb eval {
      SELECT name FROM diagrams WHERE name = :name
      } ]
    if { $names == ""} { return 0} else {return 1}
}

proc compress { text } {
    set text [ string map {" "   ""} $text ]
    lappend my {*}$text
    return [string trim $my " "]
}

proc convert2msec { text } {
	if { [scan $text "%d"] == 0 } { return "0" }
    set val [ digit_cut $text ]
	if { $val == "миллисекунд" || $val == "мс" || $val == "мсек" || $val == "msec" || $val == "ms" } {
      	return "[scan $text "%d"]"
    } elseif { $val == "секунд" || $val == "сек" || $val == "с" || $val == "sec" || $val == "s" || $val == "c" } {
      	return "[expr [scan $text "%d"]*1000]"
    } elseif { $val == "минут" || $val == "мин" || $val == "м" || $val == "min" || $val == "m" } {
      	return "[expr [scan $text "%d"]*60000 ]"
    }
}

}
