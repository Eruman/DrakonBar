gen::add_generator "PrinterPython" gen_pripy::generate38
#Генератор для Addisis, Бардынин Д.Н., 2023  
    
namespace eval gen_pripy {

variable g_callbacks

variable keywords {
and       del       from      not       while
as        elif      global    or        with
assert    else      if        pass      yield
break     except    import    print
class     exec      in        raise
continue  finally   is        return 
def       for       lambda    try
}

set correct {
    print
}

set prog_loop ""
set prog_head ""
set prog_setup ""

# Autogenerated with DRAKON Editor 1.26

proc assign { variable value } {
    #item 572
    return "$variable = $value"
}


proc bad_case { switch_var select_icon_number } {
    #item 676
    if {[ string compare -nocase $switch_var "select" ] == 0} {
        #item 682
        return "raise Exception\(\"Condition was not detected.\"\)"
    } else {
        #item 681
        return "raise Exception\(\"Not expected:  \" + str\($switch_var\)\)"
    }
}

proc block_close { output depth } {
    
}

proc commentator { line } {
    #item 45
    return "#$line"
}

proc compare { variable constant } {
    #item 581
    return "$variable == $constant"
}

proc else_start { } {
    #item 582
    return "else:"
}

proc elseif_start { } {
    #item 583
    return "elif "
}

proc extract_signature { text name } {
    #item 150
    set lines [ gen::separate_from_comments $text ]
    #item 152
    if {[ llength $lines ] == 0} {
        #item 404
        return [ list {} \
            [ gen::create_signature procedure public {} "" ] ]
    } else {
        #item 151
        set first_line [ lindex $lines 0 ]
        set first [ lindex $first_line 0 ]
        #item 1560001
        if {$first == "#method"} {
            #item 168
            set type method
            set start 1
            #item 175
            set parameters {}
            set count [ llength $lines ]
            #item 1780001
            set i $start
            while { 1 } {
                #item 1780002
                if {$i < $count} {
                    
                } else {
                    break
                }
                #item 177
                set current [ lindex $lines $i ]
                lappend parameters $current
                #item 1780003
                incr i
            }
            #item 179
            return [ list {} \
                [ gen::create_signature $type public $parameters "" ] ]
        } else {
            #item 1560002
            if {$first == "#comment"} {
                #item 171
                return [ list {} \
                    [ gen::create_signature "comment" {} {} {} ]]
            } else {
                #item 169
                set type procedure
                set start 0
                #item 175
                set parameters {}
                set count [ llength $lines ]
                #item 1780001
                set i $start
                while { 1 } {
                    #item 1780002
                    if {$i < $count} {
                        
                    } else {
                        break
                    }
                    #item 177
                    set current [ lindex $lines $i ]
                    lappend parameters $current
                    #item 1780003
                    incr i
                }
                #item 179
                return [ list {} \
                    [ gen::create_signature $type public $parameters "" ] ]
            }
        }
    }
}

proc foreach_check { item_id first second } {
    #item 26
    set go_var "_go$item_id"
    
    return $go_var
}

proc foreach_current { item_id first second } {
    #item 38
    return ""
}

proc foreach_declare { item_id first second } {
    #item 664
    return ""
}

proc foreach_incr { item_id first second } {
    #item 32
    set iter_var "_it$item_id"
    set go_var "_go$item_id"
    
    set lines [ list \
    "try:" \
    "    $first = $iter_var.next\(\)" \
    "    $go_var = True" \
    "except StopIteration:" \
    "    $go_var = False" ]
    
    return [ join $lines "\n" ]
}

proc foreach_incr3 { item_id first second } {
    #item 387
    set iter_var "_it$item_id"
    set go_var "_go$item_id"
    
    set lines [ list \
    "try:" \
    "    $first = next\($iter_var\)" \
    "    $go_var = True" \
    "except StopIteration:" \
    "    $go_var = False" ]
    
    return [ join $lines "\n" ]
}

proc foreach_init { item_id first second } {
    #item 19
    set iter_var "_it$item_id"
    set go_var "_go$item_id"
    
    set lines [ list \
    "$iter_var = iter\($second\)" \
    "try:" \
    "    $first = $iter_var.next\(\)" \
    "    $go_var = True" \
    "except StopIteration:" \
    "    $go_var = False" ]
    
    return [ join $lines "\n" ]
}

proc foreach_init3 { item_id first second } {
    #item 381
    set iter_var "_it$item_id"
    set go_var "_go$item_id"
    
    set lines [ list \
    "$iter_var = iter\($second\)" \
    "try:" \
    "    $first = next\($iter_var\)" \
    "    $go_var = True" \
    "except StopIteration:" \
    "    $go_var = False" ]
    
    return [ join $lines "\n" ]
}

proc generate { db gdb filename } {
    #item 388
    p.generate $db $gdb $filename 2
}

proc generate38 { db gdb filename } {
    #item 394
    p.generate $db $gdb $filename 3
}

proc generate_body { gdb diagram_id start_item node_list items incoming } {
    #item 590
    variable g_callbacks
    #item 591
    return [ cbody::generate_body $gdb $diagram_id $start_item $node_list \
    $items $incoming $g_callbacks ]
}

proc highlight { tokens } {
    #item 698
    set result {}
    #item 699
    set state "idle"
    #item 739
    variable keywords
    #item 7050001
    set _col705 $tokens
    set _len705 [ llength $_col705 ]
    set _ind705 0
    while { 1 } {
        #item 7050002
        if {$_ind705 < $_len705} {
            
        } else {
            break
        }
        #item 7050004
        set token [ lindex $_col705 $_ind705 ]
        #item 787
        lassign $token type text
        #item 7000001
        if {$state == "idle"} {
            #item 7150001
            if {$text == "\""} {
                #item 740
                lappend result \
                  $colors::syntax_string
                #item 722
                set state "string"
            } else {
                #item 7150002
                if {$text == "'"} {
                    #item 741
                    lappend result \
                      $colors::syntax_string
                    #item 724
                    set state "atom"
                } else {
                    #item 7150003
                    if {$text == "#"} {
                        #item 781
                        lappend result \
                          $colors::syntax_comment
                        #item 780
                        set state "comment"
                    } else {
                        #item 7250001
                        if {$type == "op"} {
                            #item 733
                            lappend result \
                              $colors::syntax_operator
                        } else {
                            #item 7250002
                            if {$type == "number"} {
                                #item 732
                                lappend result \
                                  $colors::syntax_number
                            } else {
                                #item 7250003
                                if {($type == "token") && ([contains $keywords $text])} {
                                    #item 737
                                    lappend result \
                                      $colors::syntax_keyword
                                } else {
                                    #item 734
                                    lappend result \
                                      $colors::syntax_identifier
                                }
                            }
                        }
                    }
                }
            }
        } else {
            #item 7000002
            if {$state == "string"} {
                #item 7420001
                if {$text == "\""} {
                    #item 749
                    lappend result \
                      $colors::syntax_string
                    #item 750
                    set state "idle"
                } else {
                    #item 7420002
                    if {$text == "\\"} {
                        #item 788
                        lappend result \
                          $colors::syntax_string
                        #item 751
                        set state "escaping"
                    } else {
                        #item 7420003
                        if {$text == "\n"} {
                            #item 789
                            lappend result \
                              $colors::syntax_string
                            #item 754
                            set state "idle"
                        } else {
                            #item 7420004
                            if {$text == "~"} {
                                #item 793
                                lappend result \
                                  $colors::syntax_operator
                            } else {
                                #item 790
                                lappend result \
                                  $colors::syntax_string
                            }
                        }
                    }
                }
            } else {
                #item 7000003
                if {$state == "escaping"} {
                    #item 756
                    lappend result $colors::syntax_string
                    #item 772
                    if {$text == "\n"} {
                        #item 774
                        set state "idle"
                    } else {
                        #item 755
                        set state "string"
                    }
                } else {
                    #item 7000004
                    if {$state == "atom"} {
                        #item 764
                        lappend result $colors::syntax_string
                        #item 7570001
                        if {$text == "'"} {
                            #item 765
                            set state "idle"
                        } else {
                            #item 7570002
                            if {$text == "\\"} {
                                #item 766
                                set state "atom escaping"
                            } else {
                                #item 7570003
                                if {$text == "\n"} {
                                    #item 769
                                    set state "idle"
                                } else {
                                    
                                }
                            }
                        }
                    } else {
                        #item 7000005
                        if {$state == "atom escaping"} {
                            #item 771
                            lappend result \
                             $colors::syntax_string
                            #item 775
                            if {$text == "\n"} {
                                #item 777
                                set state "idle"
                            } else {
                                #item 770
                                set state "atom"
                            }
                        } else {
                            #item 7000006
                            if {$state == "comment"} {
                                
                            } else {
                                #item 7000007
                                error "Unexpected switch value: $state"
                            }
                            #item 782
                            lappend result \
                              $colors::syntax_comment
                            #item 783
                            if {$text == "\n"} {
                                #item 785
                                set state "idle"
                            } else {
                                
                            }
                        }
                    }
                }
            }
        }
        #item 7050003
        incr _ind705
    }
    #item 697
    return $result
}

proc if_end { } {
    #item 584
    return ":"
}

proc if_start { } {
    #item 585
    return "if "
}

proc insertion_my { variable value } {
     return "procccccccc!!!!!"
}

proc make_callbacks { version } {
    #item 641
    set callbacks {}

    #gen::put_callback callbacks insertion		gen_pripy::insertion_my
    gen::put_callback callbacks assign			gen_pripy::assign
    gen::put_callback callbacks compare			gen_pripy::compare
    gen::put_callback callbacks compare2		gen_pripy::compare
    gen::put_callback callbacks while_start 	gen_pripy::while_start
    gen::put_callback callbacks if_start		gen_pripy::if_start
    gen::put_callback callbacks elseif_start	gen_pripy::elseif_start
    gen::put_callback callbacks if_end			gen_pripy::if_end
    gen::put_callback callbacks else_start		gen_pripy::else_start
    gen::put_callback callbacks pass			gen_pripy::pass
    gen::put_callback callbacks continue		gen_pripy::p.continue
    gen::put_callback callbacks return_none		gen_pripy::return_none
    gen::put_callback callbacks block_close		gen_pripy::block_close
    gen::put_callback callbacks comment			gen_pripy::commentator
    gen::put_callback callbacks bad_case		gen_pripy::bad_case	
    gen::put_callback callbacks for_check		gen_pripy::foreach_check
    gen::put_callback callbacks for_current		gen_pripy::foreach_current	
    gen::put_callback callbacks body			gen_pripy::generate_body
    gen::put_callback callbacks signature		gen_pripy::extract_signature
    gen::put_callback callbacks and				gen_pripy::p.and
    gen::put_callback callbacks or				gen_pripy::p.or
    gen::put_callback callbacks not				gen_pripy::p.not
    gen::put_callback callbacks break			"break"
    gen::put_callback callbacks declare		gen_pripy::p.declare
    gen::put_callback callbacks for_declare gen_pripy::foreach_declare
    gen::put_callback callbacks shelf gen_pripy::shelf
    #item 6420001
    if {$version == 2} {
        #item 648
        gen::put_callback callbacks for_init		gen_pripy::foreach_init
        gen::put_callback callbacks for_incr		gen_pripy::foreach_incr
    } else {
        #item 6420002
        if {$version == 3} {
            
        } else {
            #item 6420003
            error "Unexpected switch value: $version"
        }
        #item 649
        gen::put_callback callbacks for_init		gen_pripy::foreach_init3
        gen::put_callback callbacks for_incr		gen_pripy::foreach_incr3
    }
    #item 650
    return $callbacks
}

proc p.and { left right } {
    #item 621
    return "($left) and ($right)"
}

proc p.build_declaration { name signature } {
    #item 103
    unpack $signature type access parameters returns
    set param_names {}
    #item 1050001
    set _col105 $parameters
    set _len105 [ llength $_col105 ]
    set _ind105 0
    while { 1 } {
        #item 1050002
        if {$_ind105 < $_len105} {
            
        } else {
            break
        }
        #item 1050004
        set parameter [ lindex $_col105 $_ind105 ]
        #item 104
        set pname [ lindex $parameter 0 ]
        lappend param_names $pname
        #item 1050003
        incr _ind105
    }
    #item 107
    set param_string [ join $param_names ", " ]
    return "def $name\($param_string\):"
}

proc p.continue { } {
    #item 586
    return "continue"
}

proc p.declare { type name value } {
    #item 656
    return ""
}

proc p.generate { db gdb filename pversion } {
	
    mw::set_status "Generating started"
    set gen::legalLoop "повторить(* {for (*} for(* while(* repeat(*"

    set gen_arduino::prog_loop [ newline_cut [ join [ $gdb eval {
		select text
		from items
		where type = "beginend" AND ( text2 == "main")
	  } ]]]

    set gen_arduino::prog_setup [ newline_cut [ join [ $gdb eval {
        select text
        from items
        where type = "beginend" AND ( text2 == "setup")
    } ]]]
    if {$gen_arduino::prog_loop == "" && $gen_arduino::prog_setup == "" } {error "Отсутствует Пусковая диаграмма и Циклическая диаграмма. Укажите Пусковую или Циклическую диаграмму, щелкнув правой кнопкой по Началу соответствующей схемы. Можно указать обе диаграммы, при этом Пусковая выполнится однократно при запуске Ардуино, а Циклическая диаграмма будет выполняться многократно после Пусковой."}

    set gen_arduino::prog_head [ newline_cut [ join [ $gdb eval {
        select text
        from items
        where type = "beginend" AND ( text2 == "header")
    } ]]]
    if {$gen_arduino::prog_head == "" } {error "Укажите Вступительную диаграмму, щелкнув правой кнопкой по Началу соответствующей схемы."}
    set names [ $gdb eval {
        SELECT name FROM diagrams
        } ]
    #$gen_arduino::correct
    set newnames ""
    foreach name $names {
        set s1 [string first ")" $name ]
        if { $s1 > 0 } { set name [string range $name $s1+1 end] }
        set name [string trimleft $name]
        set name [string trimright $name]
        append newnames " \{" $name "\}"
    }
    append gen_arduino::correct $newnames
    

    #item 651
    variable g_callbacks
    #item 337
##################################
    set diagrams [ $gdb eval {
    	select diagram_id
      from vertices
      group by diagram_id
    } ]
	mw::set_status "...started"
    set _col1768 $diagrams
    set _len1768 [ llength $_col1768 ]
    set _ind1768 0
    while { 1 } {
		if {$_ind1768 < $_len1768} {
			} else {
			  break
		}
		set diagram_id [ lindex $_col1768 $_ind1768 ]
		# Обработать все иконки для корректировки
		mw::set_status "Rewiring      "
#		rewire_wiring_pause $gdb $diagram_id
#		rewire_wiring_pause_ins $gdb $diagram_id
		rewire_wiring_insertion $gdb $diagram_id
#		rewire_wiring_output $gdb $diagram_id
#		rewire_wiring_input $gdb $diagram_id
#		rewire_wiring_output_simple $gdb $diagram_id
#		rewire_wiring_input_simple $gdb $diagram_id
#		rewire_wiring_timer $gdb $diagram_id
#		rewire_wiring_process $gdb $diagram_id
#		rewire_wiring_shelf $gdb $diagram_id
#		rewire_wiring_converter $gdb $diagram_id
      
#		rewire_wiring_if $gdb $diagram_id
#		rewire_wiring_loopstart $gdb $diagram_id
		mw::set_status "Comparing  "
		# Скомпоновать text & text2 в единый блок
#	    	rewire_wiring_rem2text $gdb $diagram_id
	    # Отключить все иконки с изменением цвета
		rewire_color $gdb $diagram_id
		incr _ind1768
	}

#################################
    set g_callbacks [ make_callbacks $pversion ]
    #item 349
    gen::fix_graph $gdb $g_callbacks 0
    unpack [ gen::scan_file_description $db { header footer class } ] header footer class
    set functions [ gen::generate_functions $db $gdb $g_callbacks 1 ]
    #item 338
    if {[ graph::errors_occured ]} {
        
    } else {
        #item 358
        set procedures {}
        set methods {}
        #item 3600001
        set _col360 $functions
        set _len360 [ llength $_col360 ]
        set _ind360 0
        while { 1 } {
            #item 3600002
            if {$_ind360 < $_len360} {
                
            } else {
                #item 339
                set hfile [ replace_extension $filename "py" ]
                set fhandle [ open $hfile w ]
                fconfigure $fhandle -encoding utf-8
                catch {
                	p.print_to_file $fhandle $procedures \
                                     $class $methods  $header $footer
                } error_message
                
                catch { close $fhandle }

				set codeList ""
				set f [open $hfile r]
				fconfigure $f -encoding utf-8
				while {![eof $f]} {
					lappend codeList [gets $f]
				}
				close $f
				#file delete -force -- "$hfile"
				.root.pnd.text.blank.description delete 0.0 end
				.root.pnd.text.blank.description insert end [join $codeList "\n" ] 
				set codeList [join $codeList "\n" ] 
				set codeList [string map {"\n\n" "\n"}  $codeList ] 
				.root.pnd.text.entry  delete 0 end
				.root.pnd.text.entry  insert end $hfile

				#item 340
				if {$error_message == ""} {
##############################
					#set python_chan [open "python $hfile" w]
					set tail $hfile
					set last [ string last "." $tail ]
					set new_last [ string last "\/" $tail ]
					set new_path [ string range $tail 0 $new_last-1 ]
					set cut_tail [ string range $tail 0 $last-1 ]
					#tk_messageBox -icon error -message "error $tail $last $new_path"
					set command "\'$new_path\/starter.cmd\' \'$hfile\'"
					set command "starter.cmd \"$hfile\""
					set command "[auto_execok start] {} [list $cut_tail\\[file tail $hfile]]"
					set command "[auto_execok start] {} [list $hfile]"
					#set command "C:\/Users\/Bardinin.dn\/AppData\/Local\/Programs\/Thonny\/python.exe \"$hfile\""
					#tk_messageBox -icon error -message "'$command'"
					if { [ catch {exec {*}$command &} err ] } {
						tk_messageBox -icon error -message "error '$err' with\n'$command'"
					}
				} else {
                    #item 341
                    error $error_message
                }
                break
            }
            #item 3600004
            set function [ lindex $_col360 $_ind360 ]
            #item 362
            set signature [ lindex $function 2 ]
            set type [ lindex $signature 0 ]
            #item 5920001
            if {$type == "procedure"} {
                #item 363
                lappend procedures $function
		#tk_messageBox -icon error -message "$function"
            } else {
                #item 5920002
                if {$type == "comment"} {
                    
                } else {
                    #item 5920003
                    if {$type == "method"} {
                        
                    } else {
                        #item 5920004
                        error "Unexpected switch value: $type"
                    }
                    #item 365
                    if {$class == ""} {
                        #item 368
                        set name [ lindex $function 1 ]
                        set lines [ list "The file does not have a class. " \
                        "Nowhere to put method '$name'." ]
                        error [ join $lines "" ]
                        break
                    } else {
                        
                    }
                    #item 364
                    lappend methods $function
                }
            }
            #item 3600003
            incr _ind360
        }
    }
}

proc p.not { operand } {
    #item 633
    return "not ($operand)"
}

proc p.or { left right } {
    #item 652
    return "($left) or ($right)"
}

proc p.print_proc { fhandle procedure depth } {
    #item 97
    unpack $procedure diagram_id name signature body
    #item 66
    set declaration [ p.build_declaration $name $signature ]
    set indent [ gen::make_indent $depth ]
    #item 67
    set body_depth [ expr { $depth + 1 } ]
    set lines [ gen::indent $body $body_depth ]
	#gen::indent в генераторе тупо перебирает все строки и добавляет в lines с отступом
	#tk_messageBox -message "$lines"
    #item 598
    if {$lines == ""} {
        #item 600
        set lines "$indent    pass"
    } else {
        
    }
    #item 96
    puts $fhandle ""
    puts $fhandle "$indent$declaration"
    puts $fhandle $lines
    puts $fhandle ""
}

proc p.print_to_file { fhandle procs class methods header footer } {
    variable prog_head
    variable prog_loop
    variable prog_setup

    set version [ version_string ]
    puts $fhandle \
        "// Autogenerated with DRAKON Editor $version "
    puts $fhandle \
        "// Generator adopted by Bardynin Dmitry, Astrakhan-Sochi, 2023, ver.0.12"


    puts $fhandle " "
    #item 401
    if {$header == ""} {
        
    } else {
        #item 68
        puts $fhandle $header
    }
    
    set _col71 $procs
    set _len71 [ llength $_col71 ]
    set _ind71 0
    while { 1 } {
        #item 710002
        if {$_ind71 < $_len71} {
            
        } else {
            break
        }
        #item 710004
        set procedure [ lindex $_col71 $_ind71 ]
        #item 72
        p.print_proc $fhandle $procedure 0
        #item 710003
        incr _ind71
    }
    #item 69
    if {$class == ""} {
        
    } else {
        #item 77
        puts $fhandle $class
        #item 80
        if {[ llength $methods ] == 0} {
            #item 615
            if {[ line_count $class ] < 2} {
                #item 81
                puts $fhandle "    pass"
            } else {
                
            }
        } else {
            #item 740001
            set _col74 $methods
            set _len74 [ llength $_col74 ]
            set _ind74 0
            while { 1 } {
                #item 740002
                if {$_ind74 < $_len74} {
                    
                } else {
                    break
                }
                #item 740004
                set procedure [ lindex $_col74 $_ind74 ]
                #item 75
                p.print_proc $fhandle $procedure 1

                #item 740003
                incr _ind74
            }
        }
    }
    #item 76
    puts $fhandle $footer
}

proc pass { } {
    #item 587
    return "pass"
}

proc return_none { } {
    #item 588
    return "return None"
}

proc shelf { primary secondary } {
    #item 670
    return "$secondary = $primary"
}

proc while_start { } {
    #item 589
    return "while True:"
}

proc newline_cut { texttrans } {
    set texttrans [ string map {"\n"   " "} $texttrans ]
    set texttrans [ string map {"                "  " "} $texttrans ]
    set texttrans [ string map {"        "  " "} $texttrans ]
    set texttrans [ string map {"    "  " "} $texttrans ]
    set texttrans [ string map {"  "  " "} $texttrans ]
    set texttrans [ string map {"  "  " "} $texttrans ]
    set texttrans [ string map {"  "  " "} $texttrans ]
    set texttrans [ string trimleft $texttrans ]
    set texttrans [ string trimright $texttrans ]
    return $texttrans
}

proc digit_cut { texttrans } {
    set texttrans [ string map {" "  ""} $texttrans ]
    set texttrans [ string map {"0"  ""} $texttrans ]
    set texttrans [ string map {"1"  ""} $texttrans ]
    set texttrans [ string map {"2"  ""} $texttrans ]
    set texttrans [ string map {"3"  ""} $texttrans ]
    set texttrans [ string map {"4"  ""} $texttrans ]
    set texttrans [ string map {"5"  ""} $texttrans ]
    set texttrans [ string map {"6"  ""} $texttrans ]
    set texttrans [ string map {"7"  ""} $texttrans ]
    set texttrans [ string map {"8"  ""} $texttrans ]
    set texttrans [ string map {"9"  ""} $texttrans ]
    set texttrans [ string map {","  ""} $texttrans ]
    set texttrans [ string map {"."  ""} $texttrans ]
    set texttrans [ string map {"-"  ""} $texttrans ]
    return $texttrans
}

proc nodigit_cut { text } {
    tk_messageBox -message "text: $text"
    set no_dig_text [ digit_cut $text ]
    tk_messageBox -message "no_dig_text: $no_dig_text : $text"
    set text [ string map {$no_dig_text  ""} $text ]
    tk_messageBox -message "text: $text"
    set text [ string map {" "  ""} $text ]
    tk_messageBox -message "text::: $text"
    return $text
}

proc newline_cut_to { texttrans } {
    set texttrans [ string map {";\n"   " "} $texttrans ]
    return $texttrans
}

proc is_dia_name { name gdb} {
    set s1 [string last "\(" $name ]
    if { $s1 > 0 } { set name [string range $name 0 $s1-1] }
    set name [string trimright $name]
    set name [string trimleft $name]
    set name [string map {"\?" ""} $name ]

    set aaa $gen_arduino::correct
    set right_names "\{"
    foreach names $aaa {
        append right_names [newline_cut $names] "\} \{"
    }
    append right_names "\}"

    set aaa $right_names
    foreach names $aaa {
        set s1 [string first ")" $names ]
        if { $s1 > 0 } { set names [string range $names $s1+1 end] }
        set names [string map {"\?" ""} $names ]
        set names [string trimleft $names]
        set names [string trimright $names]
        if { $names == $name } {
            return 1
        }
    }
    set names [ $gdb eval {
      SELECT name FROM diagrams WHERE name = :name
      } ]
    if { $names == ""} { return 0} else {return 1}
}

proc compress { text } {
    set text [ string map {" "   ""} $text ]
    lappend my {*}$text
    return [string trim $my " "]
}

proc rewire_wiring_insertion { gdb diagram_id } {
	set starts [ $gdb eval {
	    select vertex_id
	    from vertices
	    where type = 'insertion'
	    and up != ''
	    and diagram_id = :diagram_id } ]
	set _col1734 $starts
	set _len1734 [ llength $_col1734 ]
	set _ind1734 0
	while { 1 } {
	    if {$_ind1734 < $_len1734} {
	    } else { break }
	    set vertex_id [ lindex $_col1734 $_ind1734 ]
	    unpack [ $gdb eval {
	      select text, item_id, left
	      from vertices
	      where vertex_id = :vertex_id
	      } ] text item_id left

	    set text [ join [ newline_cut $text ] ]
	    if { [ is_dia_name $text $gdb] != 1 } {
	        graph::p.error $diagram_id [ list $item_id ] "Диаграмма \"$text\" не найдена"
	    }
        set s1 [string last "\(" $text ]
        if { $s1 > 0 } {
            graph::p.error $diagram_id [ list $item_id ] "Вставка \"$text\" не может содержать аргументы"
        }
    	set new_text "$text\()"

	    $gdb eval {
	      	update vertices
	      	set text = :new_text
	      	where vertex_id = :vertex_id
	    }
	    incr _ind1734
	}
}

# Проверяем все исполняющие блоки на изменение цвета, и комментим.
proc rewire_color { gdb diagram_id } {
	set db [ mwc::get_db ]
	set starts [ $gdb eval { select vertex_id from vertices
		where diagram_id = :diagram_id } ]
	set _col1734 $starts
	set _len1734 [ llength $_col1734 ]
	set _ind1734 0
	while { 1 } {
		if {$_ind1734 < $_len1734} {} else { break }
		set vertex_id [ lindex $_col1734 $_ind1734 ]
		unpack [ $gdb eval {
			select text, text2, item_id, type
			from vertices
			where vertex_id = :vertex_id
		} ] text text2 item_id type
		# Заодно проверим, есть ли пустые иконки

		if { $text == "" && $type != "" && $type != "case"   && $type != "action"  && $type != "loopend" && $type != "beginend"} {
			tk_messageBox -message "$type $text ";
			graph::p.error $diagram_id [ list $item_id ] "Пустые иконки при генерации запрещены. $type";
		}
		set my_names [ $db eval { SELECT color FROM items WHERE diagram_id = :diagram_id AND item_id = :item_id
			AND (type = "action" OR type = "pause" OR type = "insertion" OR type = "input" OR type = "input_simple " OR type = "output_simple" OR 
			type = "converter" OR type = "output" OR type = "process" OR type = "shelf") } ]
		set lll [ llength [lindex $my_names 0] ]
		# если в позиции "цвета" что-то записано, то исключаем блок
		if { $lll > 0 } {
			set new_text "pass #Enabled color"
		} else {
			set new_text $text
		}
		$gdb eval {
			update vertices set text = :new_text
			where vertex_id = :vertex_id
		}
		incr _ind1734
	}
}

}
