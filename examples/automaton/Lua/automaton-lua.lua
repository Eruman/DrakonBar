-- Autogenerated with DRAKON Editor 1.25
tt = {}
tt.number = "number"
tt.operator = "operator"
tt.identifier = "identifier"

lex = {}
lex.initialized = false


lexer_state_idle = {}
lexer_state_identifier = {}
lexer_state_number = {}
lexer_state_operator = {}
function add_char(data, c)
    -- item 348
    table.insert(data.current, c)
end

function array_to_string(chars)
    local _iter364, _state364, i, char
    -- item 366
    local result = ""
    -- item 3640001
    _iter364, _state364, i = pairs(chars) i, char = _iter364(_state364, i)
    while true do
        -- item 3640002
        if i ~= nil then
            
        else
            break
        end
        -- item 367
        result = result .. string.char(char)
        -- item 3640003
        i, char = _iter364(_state364, i)
    end
    -- item 368
    return result
end

function create_identifier(data)
    -- item 126
    create_token(data, tt.identifier)
end

function create_number(data)
    -- item 237
    create_token(data, tt.number)
end

function create_operator(data)
    -- item 239
    create_token(data, tt.operator)
end

function create_token(data, type)
    -- item 132
    if #data.current == 0 then
        
    else
        -- item 349
        local text = data.current
        data.current = {}
        -- item 350
        local token = token_create(type, text)
        table.insert(data.tokens, token)
    end
end

function is_digit(c)
    -- item 301
    if (c >= lex.zero) and (c <= lex.nine) then
        -- item 309
        return true
    else
        -- item 310
        return false
    end
end

function is_letter(c)
    -- item 286
    if (c >= lex.a) and (c <= lex.z) then
        -- item 294
        return true
    else
        -- item 290
        if (c >= lex.ca) and (c <= lex.cz) then
            -- item 294
            return true
        else
            -- item 295
            return false
        end
    end
end

function is_long_op(first, second)
    local _iter352, _state352, i, long_op
    -- item 3520001
    _iter352, _state352, i = pairs(lex.long_ops) i, long_op = _iter352(_state352, i)
    while true do
        -- item 3520002
        if i ~= nil then
            
        else
            -- item 258
            return false
        end
        -- item 251
        if string.byte(long_op, 1) == first then
            -- item 254
            if string.byte(long_op, 2) == second then
                -- item 257
                return true
            else
                
            end
        else
            
        end
        -- item 3520003
        i, long_op = _iter352(_state352, i)
    end
end

function is_operator(c)
    -- item 194
    if lex.op_chars[c] == true then
        -- item 197
        return true
    else
        -- item 193
        return false
    end
end

function lex.init()
    local i
    -- item 266
    if lex.initialized then
        
    else
        -- item 265
        lex.op_chars = {}
        lex.long_ops = {"==", "!=", "<=", ">="}
        lex.initialized = true
        -- item 2780001
        i = 1
        while true do
            -- item 2780002
            if i <= 256 then
                
            else
                break
            end
            -- item 280
            lex.op_chars[i] = false
            -- item 2780003
            i = i + 1
        end
        -- item 269
        lex.op_chars[string.byte("!")] = true
        lex.op_chars[string.byte("=")] = true
        lex.op_chars[string.byte("<")] = true
        lex.op_chars[string.byte(">")] = true
        lex.op_chars[string.byte("-")] = true
        lex.op_chars[string.byte("+")] = true
        lex.op_chars[string.byte("/")] = true
        lex.op_chars[string.byte("\\")] = true
        lex.op_chars[string.byte("*")] = true
        lex.op_chars[string.byte("%")] = true
        lex.op_chars[string.byte("(")] = true
        lex.op_chars[string.byte(")")] = true
        lex.op_chars[string.byte("(")] = true
        lex.op_chars[string.byte(")")] = true
        lex.op_chars[string.byte("{")] = true
        lex.op_chars[string.byte("}")] = true
        lex.op_chars[string.byte(":")] = true
        lex.op_chars[string.byte(".")] = true
        lex.op_chars[string.byte("#")] = true
        lex.op_chars[string.byte(",")] = true
        lex.op_chars[string.byte("^")] = true
        lex.op_chars[string.byte("|")] = true
        lex.op_chars[string.byte("&")] = true
        lex.op_chars[string.byte("'")] = true
        lex.op_chars[string.byte("\"")] = true
        -- item 351
        lex.zero = string.byte("0")
        lex.nine = string.byte("9")
        lex.a = string.byte("a")
        lex.z = string.byte("z")
        lex.ca = string.byte("A")
        lex.cz = string.byte("Z")
        lex.under = string.byte("_")
        lex.space = string.byte(" ")
    end
end

function lexer_CleanUp(self, data, c)
    
end

function lexer_identifier_digit(self, data, c)
    -- item 60
    add_char(data, c)
    -- item 63
    self.state = lexer_state_identifier
end

function lexer_identifier_letter(self, data, c)
    -- item 59
    add_char(data, c)
    -- item 62
    self.state = lexer_state_identifier
end

function lexer_identifier_operator(self, data, c)
    -- item 276
    create_identifier(data)
    -- item 61
    add_char(data, c)
    -- item 64
    self.state = lexer_state_operator
end

function lexer_identifier_whitespace(self, data, c)
    -- item 65
    create_identifier(data)
    -- item 31
    self.state = lexer_state_idle
end

function lexer_idle_digit(self, data, c)
    -- item 45
    add_char(data, c)
    -- item 48
    self.state = lexer_state_number
end

function lexer_idle_letter(self, data, c)
    -- item 44
    add_char(data, c)
    -- item 47
    self.state = lexer_state_identifier
end

function lexer_idle_operator(self, data, c)
    -- item 46
    add_char(data, c)
    -- item 49
    self.state = lexer_state_operator
end

function lexer_idle_whitespace(self, data, c)
    -- item 23
    self.state = lexer_state_idle
end

function lexer_number_digit(self, data, c)
    -- item 77
    add_char(data, c)
    -- item 80
    self.state = lexer_state_number
end

function lexer_number_dummy(self, data, c)
    -- item 81
    self.state = lexer_state_operator
end

function lexer_number_letter(self, data, c)
    -- item 76
    add_char(data, c)
    -- item 79
    self.state = lexer_state_number
end

function lexer_number_operator(self, data, c)
    -- item 83
    create_number(data)
    -- item 78
    add_char(data, c)
    -- item 81
    self.state = lexer_state_operator
end

function lexer_number_whitespace(self, data, c)
    -- item 82
    create_number(data)
    -- item 34
    self.state = lexer_state_idle
end

function lexer_operator_digit(self, data, c)
    -- item 101
    create_operator(data)
    -- item 94
    add_char(data, c)
    -- item 97
    self.state = lexer_state_number
end

function lexer_operator_letter(self, data, c)
    -- item 100
    create_operator(data)
    -- item 93
    add_char(data, c)
    -- item 96
    self.state = lexer_state_identifier
end

function lexer_operator_operator(self, data, c)
    -- item 103
    if try_make_long_op(data, c) then
        -- item 106
        self.state = lexer_state_idle
    else
        -- item 107
        create_operator(data)
        -- item 95
        add_char(data, c)
        -- item 98
        self.state = lexer_state_operator
    end
end

function lexer_operator_whitespace(self, data, c)
    -- item 99
    create_operator(data)
    -- item 26
    self.state = lexer_state_idle
end

function main()
    local _iter357, _state357, i, token
    -- item 346
    lex.init()
    -- item 161
    local text = "foo.Bar(34 / 4-(18+m * 3)) ==800"
    local tokens = tokenize(text)
    -- item 207
    print("Text:\n" .. text)
    print("Tokens:")
    -- item 3570001
    _iter357, _state357, i = pairs(tokens) i, token = _iter357(_state357, i)
    while true do
        -- item 3570002
        if i ~= nil then
            
        else
            break
        end
        -- item 206
        token_print(token)
        -- item 3570003
        i, token = _iter357(_state357, i)
    end
end

function token_create(type, chars)
    -- item 353
    local token = {
    	type = type,
    	text = array_to_string(chars)
    }
    -- item 354
    return token
end

function token_print(token)
    -- item 333
    local message = token.type .. ": " .. token.text
    -- item 355
    print(message)
end

function tokenize(text)
    local i
    -- item 315
    local data = {
    	current = {},
    	tokens = {}
    }
    -- item 167
    local lexer = make_lexer()
    -- item 1680001
    i = 1
    while true do
        -- item 1680002
        if i <= string.len(text) then
            
        else
            break
        end
        -- item 319
        local c = string.byte(text, i)
        -- item 172
        if c == lex.under then
            -- item 181
            lexer:letter(data, c)
        else
            -- item 175
            if is_letter(c) then
                -- item 181
                lexer:letter(data, c)
            else
                -- item 178
                if is_digit(c) then
                    -- item 312
                    lexer:digit(data, c)
                else
                    -- item 183
                    if is_operator(c) then
                        -- item 313
                        lexer:operator(data, c)
                    else
                        -- item 356
                        lexer:whitespace(data, lex.space)
                    end
                end
            end
        end
        -- item 1680003
        i = i + 1
    end
    -- item 358
    lexer:whitespace(data, lex.space)
    -- item 170
    return data.tokens
end

function try_make_long_op(data, c)
    -- item 154
    local previous = data.current[1]
    -- item 155
    if is_long_op(previous, c) then
        -- item 158
        data.current = {}
        local text = { previous, c }
        local token = token_create(tt.operator, text)
        table.insert(data.tokens, token)
        -- item 159
        return true
    else
        -- item 160
        return false
    end
end

lexer_state_idle.digit = lexer_idle_digit
lexer_state_idle.dummy = lexer_idle_dummy
lexer_state_idle.letter = lexer_idle_letter
lexer_state_idle.operator = lexer_idle_operator
lexer_state_idle.whitespace = lexer_idle_whitespace
lexer_state_idle.state_name = "idle"
lexer_state_identifier.digit = lexer_identifier_digit
lexer_state_identifier.dummy = lexer_identifier_dummy
lexer_state_identifier.letter = lexer_identifier_letter
lexer_state_identifier.operator = lexer_identifier_operator
lexer_state_identifier.whitespace = lexer_identifier_whitespace
lexer_state_identifier.state_name = "identifier"
lexer_state_number.digit = lexer_number_digit
lexer_state_number.dummy = lexer_number_dummy
lexer_state_number.letter = lexer_number_letter
lexer_state_number.operator = lexer_number_operator
lexer_state_number.whitespace = lexer_number_whitespace
lexer_state_number.state_name = "number"
lexer_state_operator.digit = lexer_operator_digit
lexer_state_operator.dummy = lexer_operator_dummy
lexer_state_operator.letter = lexer_operator_letter
lexer_state_operator.operator = lexer_operator_operator
lexer_state_operator.whitespace = lexer_operator_whitespace
lexer_state_operator.state_name = "operator"
function make_lexer()
  local obj = {}
  obj.type_name = "lexer"
  obj.state = lexer_state_idle
  obj.digit = function(self, data, c)
    self.state.digit(self, data, c)
  end
  obj.dummy = function(self, data, c)
    self.state.dummy(self, data, c)
  end
  obj.letter = function(self, data, c)
    self.state.letter(self, data, c)
  end
  obj.operator = function(self, data, c)
    self.state.operator(self, data, c)
  end
  obj.whitespace = function(self, data, c)
    self.state.whitespace(self, data, c)
  end
  return obj
end
main()
