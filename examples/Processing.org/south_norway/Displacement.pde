// Autogenerated with DRAKON Editor 1.23
import java.util.Iterator;

ArrayList<PVector> displace(ArrayList<PVector> seed, int times, float xVar, float yVar) {
    // item 68
    ArrayList<PVector> output = new ArrayList<PVector>();;
    // item 700001
    int i = 0;
    while (true) {
        // item 700002
        if (i < seed.size() - 1) {
            
        } else {
            break;
        }
        // item 72
        PVector left = seed.get(i);
        PVector right = seed.get(i + 1);
        // item 73
        ArrayList<PVector> segment = displaceRecursive(left, right, times, xVar, yVar);;
        // item 74
        output.addAll(segment);
        // item 700003
        i++;
    }
    // item 75
    PVector last = seed.get(seed.size() - 1); 
    output.add(last);
    // item 69
    return output;
}

ArrayList<PVector> displaceRecursive(PVector left, PVector right, int times, float xVar, float yVar) {
    // item 16
    float top;
    float bottom;
    // item 32
    ArrayList<PVector> output = new ArrayList<PVector>();;
    // item 15
    float dx = right.x - left.x;
    // item 18
    if (right.y > left.y) {
        // item 21
        top = left.y;
        bottom = right.y;
    } else {
        // item 22
        top = right.y;
        bottom = left.y;
    }
    // item 17
    float dy = bottom - top;
    // item 29
    float leftBoundary = dx / 2 * (1 - xVar);
    float rightBoundary = dx / 2 * (1 + xVar);
    float xShift = random(leftBoundary, rightBoundary); 
    float x = left.x + xShift;
    // item 30
    float topBoundary = dy / 2 - dx * yVar;
    float bottomBoundary = dy / 2 + dx * yVar;
    float yShift = random(topBoundary, bottomBoundary);
    float y = top + yShift;
    // item 31
    PVector middle = new PVector(x, y);
    // item 34
    if (times == 1) {
        // item 41
        output.add(left);
        output.add(middle);
    } else {
        // item 37
        int nextTimes = times - 1;
        // item 39
        ArrayList<PVector> leftPart = displaceRecursive(left, middle, nextTimes, xVar, yVar);;
        // item 40
        ArrayList<PVector> rightPart = displaceRecursive(middle, right, nextTimes, xVar, yVar);;
        // item 38
        output.addAll(leftPart);
        output.addAll(rightPart);
    }
    // item 33
    return output;
}

void drawSkyline(ArrayList<PVector> seed, int timesToDisplace, float xVar, float yVar) {
    // item 47
    if (seed.size() >= 2) {
        // item 62
        ArrayList<PVector> vertices = displace(
        	seed,
        	timesToDisplace,
        	xVar,
        	yVar
        );;
        // item 61
        drawSkylineShape(vertices);
    } else {
        
    }
}

void drawSkylineShape(ArrayList<PVector> vertices) {
    Iterator<PVector> _it58 = null;
    PVector v = null;
    // item 55
    PVector leftVertex = vertices.get(0);
    PVector rightVertex = 
     vertices.get(vertices.size() - 1);
    // item 56
    beginShape();
    vertex(leftVertex.x, screenHeight);
    // item 580001
    _it58 = vertices.iterator();
    while (true) {
        // item 580002
        if (_it58.hasNext()) {
            
        } else {
            break;
        }
        // item 580004
        v = _it58.next();
        // item 60
        vertex(v.x, v.y);
    }
    // item 57
    vertex(rightVertex.x, screenHeight);
    endShape(CLOSE);
}

ArrayList<PVector> moveUp(ArrayList<PVector> vertices, float amount) {
    Iterator<PVector> _it83 = null;
    PVector v = null;
    // item 81
    ArrayList<PVector> output = new ArrayList<PVector>();;
    // item 830001
    _it83 = vertices.iterator();
    while (true) {
        // item 830002
        if (_it83.hasNext()) {
            
        } else {
            break;
        }
        // item 830004
        v = _it83.next();
        // item 85
        PVector v2 = new PVector(v.x, v.y - amount);
        output.add(v2);
    }
    // item 82
    return output;
}


